---
title: AI探秘-LangGraph使用不完全指南
date: "2025-11-04"
tags: ["AI"]
---

# LangGraph使用不完全指南：从入门到精通

LangGraph 是一个低级的编排框架和运行时环境，专为构建、管理和部署长期运行的有状态代理而设计。它专注于代理的编排，提供持久执行、流式处理、人机交互等核心功能。本文将带你从基础概念开始，逐步深入 LangGraph 的各个核心功能。

## 目录

1. [什么是LangGraph](#什么是langgraph)
2. [环境搭建](#环境搭建)
3. [基础使用](#基础使用)
   - [快速开始](#快速开始)
   - [核心概念](#核心概念)
4. [核心能力（Capabilities）](#核心能力capabilities)
   - [持久化（Persistence）](#1-持久化persistence)
   - [持久执行（Durable Execution）](#2-持久执行durable-execution)
   - [流式处理（Streaming）](#3-流式处理streaming)
   - [中断（Interrupts）](#4-中断interrupts)
   - [时间旅行（Time Travel）](#5-时间旅行time-travel)
   - [记忆（Memory）](#6-记忆memory)
   - [子图（Subgraphs）](#7-子图subgraphs)
5. [LangGraph生态系统](#langgraph生态系统)

## 什么是LangGraph

LangGraph 是一个专注于代理编排的低级框架，它提供了以下核心特性：

- **低级编排框架**：专注于代理的编排，不抽象提示或架构，给开发者最大的控制权
- **状态管理**：支持有状态的工作流和代理，能够维护和传递状态信息
- **长期运行**：支持构建能够长时间运行的代理系统
- **生产就绪**：提供可扩展的基础设施，处理有状态、长期运行工作流的独特挑战

### LangGraph vs LangChain

| 特性 | LangGraph | LangChain |
|------|-----------|-----------|
| **抽象层次** | 低级编排框架 | 高级抽象和组件 |
| **关注点** | 代理编排 | LLM应用开发 |
| **使用场景** | 需要精细控制的有状态代理 | 快速构建LLM应用 |
| **关系** | 可以独立使用 | 包含基于LangGraph构建的代理抽象 |

LangGraph 可以与 LangChain 配合使用，也可以独立使用。如果你需要更高层次的抽象，建议使用 LangChain 的代理；如果需要精细控制代理的执行流程，则使用 LangGraph。

## 环境搭建

### 安装

```bash
# 安装 LangGraph
pip install -U langgraph
```

如果需要与 LangChain 集成，可以同时安装：

```bash
# 安装 LangChain 相关包
pip install langchain
pip install langchain-core
```

## 基础使用

### 快速开始

创建一个简单的 "Hello World" 示例：

<CollapsibleCode title="Hello World 示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END

def mock_llm(state: MessagesState):
    return {"messages": [{"role": "ai", "content": "hello world"}]}

# 创建状态图
graph = StateGraph(MessagesState)

# 添加节点
graph.add_node("mock_llm", mock_llm)

# 添加边（连接节点）
graph.add_edge(START, "mock_llm")
graph.add_edge("mock_llm", END)

# 编译图
graph = graph.compile()

# 调用图
result = graph.invoke({"messages": [{"role": "user", "content": "hi!"}]})
print(result["messages"][-1]["content"])  # 输出: hello world
```
</CollapsibleCode>

### 核心概念

#### 1. StateGraph（状态图）

StateGraph 是 LangGraph 的核心，用于定义有状态的工作流：

- **状态（State）**：图的全局状态，在节点之间传递
- **节点（Node）**：执行特定功能的函数
- **边（Edge）**：定义节点之间的连接关系

#### 2. 节点（Nodes）

节点是执行实际工作的函数，接收状态并返回状态更新：

<CollapsibleCode title="节点定义示例" language="python">
```python
from langgraph.graph import MessagesState

def process_message(state: MessagesState):
    """处理消息的节点"""
    messages = state["messages"]
    # 执行处理逻辑
    new_message = {"role": "ai", "content": "处理后的回复"}
    return {"messages": messages + [new_message]}
```
</CollapsibleCode>

#### 3. 边（Edges）

边定义了节点之间的连接：

- **固定边**：使用 `add_edge()` 定义固定的连接
- **条件边**：使用 `add_conditional_edges()` 根据条件动态选择下一个节点

<CollapsibleCode title="条件边示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END

def should_continue(state: MessagesState):
    """决定下一个节点"""
    messages = state["messages"]
    last_message = messages[-1]
    if last_message["role"] == "user":
        return "process"
    else:
        return END

graph = StateGraph(MessagesState)
graph.add_node("process", process_message)
graph.add_edge(START, "process")
graph.add_conditional_edges("process", should_continue)
```
</CollapsibleCode>

## 核心能力（Capabilities）

LangGraph 提供了丰富的核心能力，支持构建复杂的有状态代理系统。

### 1. 持久化（Persistence）

持久化允许将代理的状态保存到外部存储，以便在失败或重启后恢复。

#### 为什么需要持久化

- **容错性**：系统失败后可以从检查点恢复
- **长期运行**：支持长时间运行的代理
- **状态管理**：跨会话保持状态

#### 实现方式

LangGraph 支持多种持久化后端：

<CollapsibleCode title="内存持久化示例" language="python">
```python
from langgraph.checkpoint.memory import MemorySaver
from langgraph.graph import StateGraph, MessagesState, START, END

# 创建内存检查点保存器
memory = MemorySaver()

# 创建图并启用持久化
graph = StateGraph(MessagesState)
graph.add_node("mock_llm", mock_llm)
graph.add_edge(START, "mock_llm")
graph.add_edge("mock_llm", END)

# 编译时启用持久化
graph = graph.compile(checkpointer=memory)

# 使用线程ID标识不同的会话
config = {"configurable": {"thread_id": "1"}}
result = graph.invoke(
    {"messages": [{"role": "user", "content": "hi!"}]},
    config=config
)
```
</CollapsibleCode>

<CollapsibleCode title="文件系统持久化示例" language="python">
```python
from langgraph.checkpoint.filesystem import FileSystemSaver

# 使用文件系统作为检查点存储
checkpointer = FileSystemSaver(path="./checkpoints")

graph = graph.compile(checkpointer=checkpointer)

# 继续执行，会从上次的检查点恢复
result = graph.invoke(
    {"messages": [{"role": "user", "content": "继续对话"}]},
    config=config
)
```
</CollapsibleCode>

### 2. 持久执行（Durable Execution）

持久执行确保代理能够在失败后恢复，并从上次中断的地方继续执行。

#### 核心特性

- **自动检查点**：在执行过程中自动保存状态
- **故障恢复**：系统失败后自动恢复
- **长时间运行**：支持运行数小时甚至数天的代理

<CollapsibleCode title="持久执行示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.checkpoint.memory import MemorySaver

def long_running_task(state: MessagesState):
    """长时间运行的任务"""
    # 模拟需要长时间执行的任务
    import time
    time.sleep(5)  # 模拟耗时操作
    return {"messages": state["messages"] + [{"role": "ai", "content": "任务完成"}]}

graph = StateGraph(MessagesState)
graph.add_node("long_task", long_running_task)
graph.add_edge(START, "long_task")
graph.add_edge("long_task", END)

# 启用持久执行
memory = MemorySaver()
graph = graph.compile(checkpointer=memory)

# 配置线程ID，支持多个并发会话
config = {"configurable": {"thread_id": "session_1"}}
result = graph.invoke(
    {"messages": [{"role": "user", "content": "开始任务"}]},
    config=config
)
```
</CollapsibleCode>

### 3. 流式处理（Streaming）

流式处理允许实时获取代理的执行状态，提供更好的用户体验。

#### 流式事件类型

LangGraph 支持多种流式事件：

- **节点开始**：节点开始执行时触发
- **节点结束**：节点完成执行时触发
- **状态更新**：状态发生变化时触发

<CollapsibleCode title="流式处理示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END

graph = StateGraph(MessagesState)
graph.add_node("mock_llm", mock_llm)
graph.add_edge(START, "mock_llm")
graph.add_edge("mock_llm", END)
graph = graph.compile()

# 流式调用
for event in graph.stream(
    {"messages": [{"role": "user", "content": "hi!"}]}
):
    # 处理流式事件
    for node_name, node_output in event.items():
        print(f"节点 {node_name} 输出: {node_output}")
```
</CollapsibleCode>

<CollapsibleCode title="流式处理详细示例" language="python">
```python
def agent_node(state: MessagesState):
    """代理节点"""
    messages = state["messages"]
    # 模拟LLM调用
    response = {"role": "ai", "content": f"回复: {messages[-1]['content']}"}
    return {"messages": messages + [response]}

graph = StateGraph(MessagesState)
graph.add_node("agent", agent_node)
graph.add_edge(START, "agent")
graph.add_edge("agent", END)
graph = graph.compile()

# 流式调用并实时显示
for event in graph.stream({"messages": [{"role": "user", "content": "你好"}]}):
    if "agent" in event:
        print(f"代理响应: {event['agent']['messages'][-1]['content']}")
```
</CollapsibleCode>

### 4. 中断（Interrupts）

中断允许在代理执行过程中暂停，等待外部输入或人工干预后再继续执行。

#### 使用场景

- **人工审核**：在关键决策点暂停，等待人工确认
- **外部输入**：等待用户输入或外部API响应
- **条件检查**：在特定条件下暂停执行

<CollapsibleCode title="中断示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.graph.message import add_messages
from langgraph.checkpoint.memory import MemorySaver

def human_review_node(state: MessagesState):
    """需要人工审核的节点"""
    messages = state["messages"]
    # 检查是否需要人工审核
    if "审核" in messages[-1].get("content", ""):
        # 抛出中断，等待人工输入
        raise Interrupt("等待人工审核")
    return {"messages": messages}

def continue_after_review(state: MessagesState):
    """人工审核后继续"""
    return {"messages": state["messages"] + [{"role": "ai", "content": "审核通过，继续执行"}]}

graph = StateGraph(MessagesState)
graph.add_node("review", human_review_node)
graph.add_node("continue", continue_after_review)
graph.add_edge(START, "review")
graph.add_edge("review", "continue")
graph.add_edge("continue", END)

memory = MemorySaver()
graph = graph.compile(checkpointer=memory)

# 第一次调用，会在 review 节点中断
config = {"configurable": {"thread_id": "1"}}
try:
    result = graph.invoke(
        {"messages": [{"role": "user", "content": "需要审核的内容"}]},
        config=config
    )
except Exception as e:
    print(f"执行中断: {e}")

# 人工审核后，更新状态并继续
graph.update_state(
    config,
    {"messages": [{"role": "user", "content": "审核通过"}]}
)

# 继续执行
result = graph.invoke(None, config=config)
```
</CollapsibleCode>

### 5. 时间旅行（Time Travel）

时间旅行允许回溯和前进代理的执行状态，这对于调试和状态管理非常有用。

#### 功能特性

- **状态回溯**：返回到之前的任意检查点
- **状态前进**：从检查点继续执行
- **调试支持**：方便调试和测试

<CollapsibleCode title="时间旅行示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.checkpoint.memory import MemorySaver

graph = StateGraph(MessagesState)
graph.add_node("step1", lambda s: {"messages": s["messages"] + [{"role": "ai", "content": "步骤1"}]})
graph.add_node("step2", lambda s: {"messages": s["messages"] + [{"role": "ai", "content": "步骤2"}]})
graph.add_edge(START, "step1")
graph.add_edge("step1", "step2")
graph.add_edge("step2", END)

memory = MemorySaver()
graph = graph.compile(checkpointer=memory)

config = {"configurable": {"thread_id": "1"}}

# 执行到步骤1
result1 = graph.invoke(
    {"messages": [{"role": "user", "content": "开始"}]},
    config=config
)

# 获取所有检查点
checkpoints = list(memory.list(config))
print(f"检查点数量: {len(checkpoints)}")

# 回溯到特定检查点
if len(checkpoints) > 0:
    checkpoint_id = checkpoints[0]["checkpoint_id"]
    # 从检查点恢复状态
    state = memory.get({"configurable": {"thread_id": "1", "checkpoint_id": checkpoint_id}})
    print(f"恢复的状态: {state}")
```
</CollapsibleCode>

### 6. 记忆（Memory）

记忆系统支持代理的短期工作记忆和跨会话的长期记忆。

#### 记忆类型

- **短期记忆**：当前会话的工作记忆
- **长期记忆**：跨会话的持久记忆

<CollapsibleCode title="记忆管理示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END
from langgraph.checkpoint.memory import MemorySaver
from typing import TypedDict, Annotated
from langgraph.graph.message import add_messages

class State(TypedDict):
    messages: Annotated[list, add_messages]
    context: dict  # 额外的上下文信息

def agent_with_memory(state: State):
    """带记忆的代理节点"""
    messages = state["messages"]
    context = state.get("context", {})
    
    # 使用上下文信息
    if "user_name" in context:
        greeting = f"你好，{context['user_name']}！"
    else:
        greeting = "你好！"
    
    # 更新上下文
    context["last_interaction"] = "问候"
    
    return {
        "messages": messages + [{"role": "ai", "content": greeting}],
        "context": context
    }

graph = StateGraph(State)
graph.add_node("agent", agent_with_memory)
graph.add_edge(START, "agent")
graph.add_edge("agent", END)

memory = MemorySaver()
graph = graph.compile(checkpointer=memory)

config = {"configurable": {"thread_id": "1"}}

# 第一次交互，设置用户名称
result1 = graph.invoke(
    {
        "messages": [{"role": "user", "content": "我是张三"}],
        "context": {"user_name": "张三"}
    },
    config=config
)

# 第二次交互，记忆会保留
result2 = graph.invoke(
    {"messages": [{"role": "user", "content": "你好"}]},
    config=config
)

print(result2["messages"][-1]["content"])  # 会包含用户名称
```
</CollapsibleCode>

### 7. 子图（Subgraphs）

子图允许将复杂的代理逻辑拆分为更小的、可重用的子图，提升模块化和可维护性。

#### 优势

- **模块化**：将复杂逻辑拆分为独立模块
- **可重用**：子图可以在多个地方重复使用
- **可维护**：更容易理解和维护

<CollapsibleCode title="子图示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END

def preprocess_node(state: MessagesState):
    """预处理子图"""
    messages = state["messages"]
    # 预处理逻辑
    processed = {"role": "user", "content": f"[处理] {messages[-1]['content']}"}
    return {"messages": messages[:-1] + [processed]}

def main_process_node(state: MessagesState):
    """主处理节点"""
    messages = state["messages"]
    return {"messages": messages + [{"role": "ai", "content": "主处理完成"}]}

# 创建预处理子图
preprocess_graph = StateGraph(MessagesState)
preprocess_graph.add_node("preprocess", preprocess_node)
preprocess_graph.add_edge(START, "preprocess")
preprocess_graph.add_edge("preprocess", END)
preprocess_graph = preprocess_graph.compile()

# 创建主图，将子图作为节点
main_graph = StateGraph(MessagesState)
main_graph.add_node("preprocess", preprocess_graph)
main_graph.add_node("main_process", main_process_node)
main_graph.add_edge(START, "preprocess")
main_graph.add_edge("preprocess", "main_process")
main_graph.add_edge("main_process", END)
main_graph = main_graph.compile()

# 使用主图
result = main_graph.invoke({"messages": [{"role": "user", "content": "原始消息"}]})
print(result["messages"])
```
</CollapsibleCode>

<CollapsibleCode title="复杂子图示例" language="python">
```python
from langgraph.graph import StateGraph, MessagesState, START, END

# 创建一个可重用的对话子图
def create_conversation_subgraph():
    """创建对话处理子图"""
    def respond(state: MessagesState):
        messages = state["messages"]
        last_msg = messages[-1]["content"]
        return {"messages": messages + [{"role": "ai", "content": f"回复: {last_msg}"}]}
    
    subgraph = StateGraph(MessagesState)
    subgraph.add_node("respond", respond)
    subgraph.add_edge(START, "respond")
    subgraph.add_edge("respond", END)
    return subgraph.compile()

# 主图使用多个子图
main_graph = StateGraph(MessagesState)
conversation = create_conversation_subgraph()

main_graph.add_node("conversation", conversation)
main_graph.add_edge(START, "conversation")
main_graph.add_edge("conversation", END)
main_graph = main_graph.compile()

result = main_graph.invoke({"messages": [{"role": "user", "content": "你好"}]})
```
</CollapsibleCode>

## LangGraph生态系统

LangGraph 可以与 LangChain 生态系统无缝集成：

### LangSmith

- **调试和可观察性**：可视化代理执行路径，追踪状态转换
- **评估**：评估代理轨迹，识别性能问题
- **生产监控**：在生产环境中获得可见性

### LangChain

- **集成组件**：使用 LangChain 的模型、工具和组件
- **代理抽象**：LangChain 提供了基于 LangGraph 构建的高级代理抽象

### 使用建议

- **独立使用**：如果需要精细控制，直接使用 LangGraph
- **配合使用**：结合 LangChain 的组件和工具，快速构建应用
- **生产部署**：使用 LangSmith 进行监控和调试

## 总结

LangGraph 是一个强大的低级编排框架，提供了构建有状态、长期运行的代理所需的核心能力：

1. **持久化**：确保状态不丢失
2. **持久执行**：支持长时间运行
3. **流式处理**：实时响应
4. **中断机制**：支持人工干预
5. **时间旅行**：方便调试
6. **记忆系统**：保持上下文
7. **子图**：模块化设计

通过合理使用这些能力，可以构建出功能强大、稳定可靠的代理系统。

## 延伸阅读

- [LangGraph官方文档](https://docs.langchain.com/oss/python/langgraph/overview)
- [LangGraph GitHub仓库](https://github.com/langchain-ai/langgraph)
- [LangChain官方文档](https://python.langchain.com/)
